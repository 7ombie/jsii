(do for item in items {
    if item.meets(requirements) { item0, item1 }
    spam
    eggs
})

x in foo()
x not in y

a = do {
    foo + bar
    return spam + eggs
}

b = do function of x, y {
    x * y
    return x + y
}

c = do async function of x, y {
    x * y
    return x + y
}

d = do if item.meets(requirements) {
    item0
    return item1
}

do while x > y { x -= 1, return y }

function f { return true }.bind(fish)

function j of x, y, z { yield false }
async function spam { return 1 }
async function of args { yield 1 }

await [function f of x, y {

    x + y    
    sum
}, 1, 2, 3,

    1 + """
    spam and eggs
        line two
    """
]

delete "foobar \(

    1 + """
    spam and eggs
        line two
    """
)"

"foobar \("()")"

"outer: \("inner: \( "innermost: \(boogie + woogie, 100 * 45)^^^"  ) 2"  )"

spam.com """
    line 1
        `line 2` ${ foo } (indented four spaces)
    \(1, 2, 3)
    line 4
    """

html.tag "
line one: onside
  line two: indented \(1, 2) spaces    
line three: onside \(3, 4, 5) again
"

for each in range { breakfast(), while x > y { console.log(dude) }, while x > y { console.log(dude) } }
for each of (range) {
    breakfast()
    while x > y { console.log(dude) }
}
for each on foo.bar { breakfast() }
for each from spam() { breakfast() }

while x > y { console.log(dude) }

puss in boots
puss of boots
puss on boots

{x: 4, y: 5, z, __proto__: Bar}
{as Object, __proto__: Array, name: "Bob", salary: 20000}

foo[1 + 2]
bar(1, 2, 3 + 3)
(1 on 2) * (not 2, 3, 4)

x == 4
y != z

if p0 { foo } else if p1 { bar } else { spam }

do async function { return await true }

html.tag "
line one: onside
  line two: indented \(1, 2, 3) spaces    
line three: onside again
"

x == freeze 1
spam != green.eggs and ham

foo!bar?spam.eggs

theory is String
theory is not String

foo: while expression { break foo, continue foo }

async function f { await call() }

function foo { yield from something }
function (prefix + "bar") of args { return somethingElse + 1 }

dev function {
    dance: while x while y {
        o is packed
        o is sealed
        o is frozen
        if o is not packed yield 1
        o is not sealed
        o is not frozen
        function { moves: for thing from otherThing { break moves } }
    }
}

function (foo) of x, y { return 100 }
function foo of x, y { return 200 }
function of x, y { return 0x100 - 0x200 }
throw Foo("spam and eggs")
dev if x { Y }
dev 1 + 2 * 3 + 3
pack new Foo(x, y, z)
seal new Bar(spam, eggs) + foo
freeze 1 + 2 when x * y else spam + eggs
(1, 2, 3, seal 4)

28n
4.3K
300M
14px
12.345em
34mm
26p
34.3T
12vh
12.3vmax

28//3 / 43
4.3\\10 \ 4
300//3 % 5
1434.435\\45 - 1

[1, 2, 3]
(not 1, 2, 3)
{x: 1, y: 2, x}
yay