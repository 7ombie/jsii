import { parse } from "../compiler/parser.js"
import { put, Stack } from "../compiler/helpers.js"

export function * fix(source, {dev=false}={}) {

    function * walk(statements) { // internal helper

        /* This function takes the iterator generated by the parser, iterates over the statements
        it generates, and calls the `fix` method on each, before yielding it. The `fix` method is
        implemented by `Token` to iterate over the operands, calling their `fix` methods. As such,
        it's possible to call `fix` on one token, and walk it recursively.

        Subclasses of `Token` can override `fix` to interpolate their own logic for validating and
        fixing (mutating) their state, their operands and the stacks that make up the Fixer Stage
        API, before recursively invoking `fix` on each of their children. */

        for (const statement of statements) { statement.fix(api, null); yield statement }
    }

    const api = {
        yieldstack: new Stack(),        // looks for `yield` and `yield from` inside functions
        scopestack: new Stack({}),      // stores the namespaces that currently form the scope
        awaitstack: new Stack(true),    // tracks whether we're in an async function or onside
        paramstack: new Stack(false),   // tracks whether we're currently in a parameters list
        blockstack: new Stack(false),   // tracks whether we're in a block (within a function)
        loopstack:  new Stack(false),   // tracks whether we're in a loop (within in function)
        callstack:  new Stack(false),   // tracks whether we're in any kind of function at all
    };

    yield * walk(parse(source, {dev}));
}
